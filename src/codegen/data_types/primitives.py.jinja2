{{ "from __future__ import annotations" if x.id in ["DT", "TM", "NM"] }}
from ...base import HL7Primitive, HL7PrimitiveParseException
{{ "from datetime import datetime, date" if x.id in ["DT"] }}
{{ "from datetime import datetime, time" if x.id in ["TM"] }}
{{ "from zoneinfo import ZoneInfo" if x.id in ["TM"] }}
{{ "import re" if x.id in ["TM"] }}
{% set short_desc = x.description.split(".")[0].replace("\n", "").replace('"', "") if x.description %}
{% set param_name = "yymmdd" if x.id == "DT" else x.id|lower %}


"""
HL7 Version: {{ version }}
{{ x.type }} - {{ x.id }}
"""

class {{ x.id }}(str, HL7Primitive):
    """
    {{ x.id }} - {{ x.name }} (len: {{ x.length }})
    ---
    {{ x.description.replace("\"", "") if x.description }}
    ---
    https://hl7-definition.caristix.com/v2/HL7v{{ version }}/DataTypes/{{ x.id }}
    """
    _hl7_version = "{{ version }}"
    _hl7_type = "PRIMITIVE_DATA_TYPE"
    _hl7_length = {{ x.length }}
    _hl7_id = "{{ x.id }}"
    _hl7_name = "{{ x.name }}"
    _hl7_description = """{{ short_desc }}"""
    _hl7_ref_url = "https://hl7-definition.caristix.com/v2/HL7v{{ version }}/DataTypes/{{ x.id }}"

    {% if x.id == "NM" %}
    def __new__(cls, nm: str | int | float):
        content = str(nm)
        if len(content) > 16:
            raise HL7PrimitiveParseException("NM content exceeds maximum length of 16 characters")
        # Validate format (optional sign, digits, optional decimal point)
        if not content.replace('.', '').replace('-', '').replace('+', '').isdigit():
            raise HL7PrimitiveParseException("Invalid numeric format")
        return super().__new__(cls, content)

    {% elif x.id == "TM" %}

    # Regex pattern for validating TM format
    __pattern = re.compile(
        r'^(?P<hour>[0-1][0-9]|2[0-3])'
        r'(?:(?P<minute>[0-5][0-9])'
        r'(?:(?P<second>[0-5][0-9])'
        r'(?:\.(?P<fraction>[0-9]{1,4}))?)?)?'
        r'(?P<timezone>[+-][0-2][0-9][0-5][0-9])?$'
    )
    def __new__(cls, tm: str):
        if len(tm) > 16:
            raise HL7PrimitiveParseException("TM content exceeds maximum length of 16 characters")
        if not cls.__pattern.match(tm):
            raise HL7PrimitiveParseException("Invalid TM format")
        return super().__new__(cls, tm)

    {% else %}
    def __new__(cls, {{ param_name.replace("is", "is_") }}: str):
        {% if x.length %}
        if len({{ param_name.replace("is", "is_") }}) > {{ x.length }}:
            raise HL7PrimitiveParseException("{{ x.id }} - {{ x.name }} content exceeds maximum length of {{ x.length }} characters")
        {% endif %}
        return super().__new__(cls, {{ param_name.replace("is", "is_") }})
    {% endif %}


    {% if x.id == "TM" %}

    @classmethod
    def from_time(cls, t: time, include_timezone: bool = True) -> TM:
        """Create a TM instance from a time object."""
        basic = t.strftime('%H%M%S')
        if t.microsecond:
            # Convert microseconds to 4 decimal places
            fraction = f".{t.microsecond:06d}"[:5]
            basic += fraction

        if include_timezone and t.tzinfo:
            offset = t.tzinfo.utcoffset(None)
            if offset is not None:
                minutes = offset.total_seconds() / 60
                sign = '+' if minutes >= 0 else '-'
                hours, mins = divmod(abs(int(minutes)), 60)
                basic += f"{sign}{hours:02d}{mins:02d}"

        return cls(basic)

    @classmethod
    def from_datetime(cls, dt: datetime, include_timezone: bool = True) -> TM:
        """Create a TM instance from a datetime object."""
        return cls.from_time(dt.timetz(), include_timezone)

    @classmethod
    def now(cls, tz: str | ZoneInfo | None = None) -> TM:
        """Create a TM instance for current time."""
        if isinstance(tz, str):
            tz = ZoneInfo(tz)
        return cls.from_datetime(datetime.now(tz))

    @classmethod
    def from_hhmmss(
        cls,
        hour: int,
        minute: int | None = None,
        second: int | None = None,
        *,
        microsecond: int | None = None,
        timezone_offset: tuple[int, int] | None = None
    ) -> TM:
        """
        Create a TM instance from time components.
        timezone_offset should be a tuple of (hours, minutes) representing UTC offset
        """
        if not 0 <= hour <= 23:
            raise HL7PrimitiveParseException("Hour must be between 0 and 23")

        result = f"{hour:02d}"

        if minute is not None:
            if not 0 <= minute <= 59:
                raise HL7PrimitiveParseException("Minute must be between 0 and 59")
            result += f"{minute:02d}"

            if second is not None:
                if not 0 <= second <= 59:
                    raise HL7PrimitiveParseException("Second must be between 0 and 59")
                result += f"{second:02d}"

                if microsecond is not None:
                    if not 0 <= microsecond <= 999999:
                        raise HL7PrimitiveParseException("Microsecond must be between 0 and 999999")
                    result += f".{microsecond:06d}"[:5]  # Truncate to 4 decimal places

        if timezone_offset is not None:
            tz_hour, tz_minute = timezone_offset
            if not -23 <= tz_hour <= 23 or not 0 <= tz_minute <= 59:
                raise HL7PrimitiveParseException("Invalid timezone offset")
            sign = '+' if tz_hour >= 0 else '-'
            result += f"{sign}{abs(tz_hour):02d}{tz_minute:02d}"

        return cls(result)

    @classmethod
    def from_iso(cls, iso_time: str) -> TM:
        """Create a TM instance from an ISO format time string (HH:MM:SS.mmm±HHMM)."""
        for fmt in ["%H:%M:%S.%f%z", "%H:%M:%S%z", "%H:%M:%S.%f", "%H:%M:%S"]:
            try:
                t = datetime.strptime(iso_time, "%H:%M:%S.%f%z").time()
                return cls.from_time(t)
            except ValueError:
                pass
        return HL7PrimitiveParseException("Invalid ISO format time")

    def to_time(self) -> time:
        """Convert to time object."""
        match = self._pattern.match(self)
        if not match:
            raise HL7PrimitiveParseException("Invalid TM format")

        parts = match.groupdict()
        hour = int(parts['hour'])
        minute = int(parts['minute']) if parts['minute'] else 0
        second = int(parts['second']) if parts['second'] else 0
        microsecond = int(parts['fraction'].ljust(6, '0')) if parts['fraction'] else 0

        timezone = None
        if parts['timezone']:
            sign = 1 if parts['timezone'][0] == '+' else -1
            tz_hour = int(parts['timezone'][1:3])
            tz_minute = int(parts['timezone'][3:5])
            timezone = ZoneInfo(f"Etc/GMT{'-' if sign > 0 else '+'}{tz_hour}")

        return time(hour, minute, second, microsecond, timezone)

    def to_iso(self) -> str:
        """Convert to ISO format (HH:MM:SS.mmm±HHMM)."""
        return self.to_time().isoformat()

    @property
    def hour(self) -> int:
        """Get the hour component."""
        return int(self[:2])

    @property
    def minute(self) -> int | None:
        """Get the minute component if available."""
        return int(self[2:4]) if len(self) >= 4 else None

    @property
    def second(self) -> int | None:
        """Get the second component if available."""
        return int(self[4:6]) if len(self) >= 6 else None

    @property
    def fraction(self) -> str | None:
        """Get the fractional seconds if available."""
        match = self._pattern.match(self)
        return match.group('fraction') if match and match.group('fraction') else None

    @property
    def timezone(self) -> tuple[int, int] | None:
        """Get the timezone offset as (hour, minute) tuple if available."""
        match = self._pattern.match(self)
        if match and match.group('timezone'):
            tz = match.group('timezone')
            sign = 1 if tz[0] == '+' else -1
            return (sign * int(tz[1:3]), int(tz[3:5]))
        return None
    {% endif %}






    {% if x.id == "DT" %}
    @classmethod
    def from_datetime(cls, dt: datetime) -> DT:
        """Create a DT instance from a datetime object."""
        return cls(dt.strftime('%Y%m%d'))

    @classmethod
    def from_date(cls, d: date) -> DT:
        """Create a DT instance from a date object."""
        return cls(d.strftime('%Y%m%d'))

    @classmethod
    def from_ymd(cls, year: int, month: int | None = None, day: int | None = None) -> DT:
        """
        Create a DT instance from year, month, and day components.
        Month and day are optional per HL7 v2.3+ specification.
        """
        if not 1 <= year <= 9999:
            raise HL7PrimitiveParseException("Year must be between 1 and 9999")

        result = f"{year:04d}"

        if month is not None:
            if not 1 <= month <= 12:
                raise HL7PrimitiveParseException("Month must be between 1 and 12")
            result += f"{month:02d}"

            if day is not None:
                if not 1 <= day <= 31:  # Simple validation, doesn't check month-specific day limits
                    raise HL7PrimitiveParseException("Day must be between 1 and 31")
                result += f"{day:02d}"
        elif day is not None:
            raise HL7PrimitiveParseException("Cannot specify day without month")

        return cls(result)

    @classmethod
    def today(cls) -> DT:
        """Create a DT instance for today's date."""
        return cls.from_date(date.today())

    @classmethod
    def from_iso(cls, iso_date: str) -> DT:
        """Create a DT instance from an ISO format date string (YYYY-MM-DD)."""
        try:
            return cls.from_date(date.fromisoformat(iso_date))
        except HL7PrimitiveParseException:
            raise HL7PrimitiveParseException("Invalid ISO date format. Expected YYYY-MM-DD")

    def to_datetime(self) -> datetime:
        """Convert to datetime object. Time components will be set to midnight."""
        length = len(self)
        if length == 4:
            return datetime(int(self), 1, 1)
        elif length == 6:
            return datetime(int(self[:4]), int(self[4:6]), 1)
        elif length == 8:
            return datetime(int(self[:4]), int(self[4:6]), int(self[6:8]))
        else:
            raise HL7PrimitiveParseException("Invalid DT format")

    def to_date(self) -> date:
        """Convert to date object."""
        return self.to_datetime().date()

    def to_iso(self) -> str:
        """Convert to ISO format (YYYY-MM-DD)."""
        length = len(self)
        if length == 4:
            return f"{self}"
        elif length == 6:
            return f"{self[:4]}-{self[4:6]}"
        elif length == 8:
            return f"{self[:4]}-{self[4:6]}-{self[6:8]}"
        else:
            raise HL7PrimitiveParseException("Invalid DT format")

    @property
    def year(self) -> int:
        """Get the year component."""
        return int(self[:4])

    @property
    def month(self) -> int | None:
        """Get the month component if available."""
        return int(self[4:6]) if len(self) >= 6 else None

    @property
    def day(self) -> int | None:
        """Get the day component if available."""
        return int(self[6:8]) if len(self) == 8 else None
    {% endif %}

    {% if x.id == "NM" %}
    def __add__(self, other):
        """Add two NM values or NM and a number."""
        return NM(float(self) + float(other))

    def __sub__(self, other):
        """Subtract two NM values or NM and a number."""
        return NM(float(self) - float(other))

    def __mul__(self, other):
        """Multiply two NM values or NM and a number."""
        return NM(float(self) * float(other))

    def __truediv__(self, other):
        """Divide two NM values or NM and a number."""
        return NM(float(self) / float(other))

    @classmethod
    def from_int(cls, value: int) -> NM:
        """Create NM from integer."""
        return cls(str(value))

    @classmethod
    def from_float(cls, value: float, precision: int = None) -> NM:
        """Create NM from float with optional precision."""
        if precision is not None:
            return cls(f"{value:.{precision}f}")
        return cls(str(value))

    def to_int(self) -> int:
        """Convert to integer (truncates decimal part)."""
        return int(float(self))

    def to_float(self) -> float:
        """Convert to float."""
        return float(self)

    @property
    def is_integer(self) -> bool:
        """Check if the number is an integer (no decimal part)."""
        return float(self).is_integer()

    @property
    def is_positive(self) -> bool:
        """Check if the number is positive."""
        return float(self) > 0

    @property
    def is_negative(self) -> bool:
        """Check if the number is negative."""
        return float(self) < 0
        # Convert input to string if it's a number
    {% endif %}
